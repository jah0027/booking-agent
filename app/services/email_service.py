"""Email service for sending and receiving emails via Resend"""


import os
import resend
import structlog

from email.utils import parseaddr
from datetime import datetime

from typing import Optional, List, Dict, Any
from app.config import settings

logger = structlog.get_logger()


class EmailService:
    """Handle sending emails via Resend and processing inbound webhooks"""
    
    def __init__(self, api_key: Optional[str] = None):
        """Initialize Resend email service
        
        Args:
            api_key: Resend API key (defaults to settings.resend_api_key)
        """
        api_key = api_key or settings.resend_api_key
        print("[DEBUG] RESEND_API_KEY loaded:", api_key)  # Debug print for troubleshooting
        if not api_key:
            logger.warning("RESEND_API_KEY not set - email sending will fail")
        else:
            resend.api_key = api_key
        
        self.from_address = settings.email_from_address or 'agent@sickdaywithferris.band'
        self.from_name = getattr(settings, 'email_from_name', 'SickDay Agent')
        self.agent_name = getattr(settings, 'agent_name', 'SickDay Agent')
        
        logger.info("Initialized Resend email service", from_address=self.from_address, has_api_key=bool(api_key))
    
    async def send_email(
        self,
        to: List[str],
        subject: str,
        html: str,
        text: Optional[str] = None,
        reply_to: Optional[str] = None,
        cc: Optional[List[str]] = None,
        bcc: Optional[List[str]] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Send an email via Resend
        
        Args:
            to: List of recipient email addresses
            subject: Email subject line
            html: HTML email content
            text: Plain text email content (optional, fallback if HTML not supported)
            reply_to: Reply-to email address
            cc: List of CC recipients
            bcc: List of BCC recipients
            metadata: Custom metadata to attach to email (e.g., conversation_id, booking_id)
        
        Returns:
            Dict containing email_id and status
        
        Raises:
            Exception if email send fails
        """
        try:
            params = {
                "from": f"{self.from_name} <{self.from_address}>",
                "to": to,
                "subject": subject,
                "html": html,
            }
            
            if text:
                params["text"] = text
            
            if reply_to:
                params["reply_to"] = reply_to
            
            if cc:
                params["cc"] = cc
            
            if bcc:
                params["bcc"] = bcc
            
            # Resend supports tags for categorization (must be ASCII alphanumeric, underscore, dash only)
            import re
            def sanitize_tag(s):
                if s is None:
                    return "none"
                s = str(s)
                # Remove non-ASCII and replace with _
                s = re.sub(r"[^A-Za-z0-9_-]", "_", s)
                # Remove leading/trailing underscores and collapse repeats
                s = re.sub(r'_+', '_', s).strip('_')
                return s or "none"
            if metadata:
                params["tags"] = [
                    {"name": sanitize_tag(key), "value": sanitize_tag(value)}
                    for key, value in metadata.items()
                ]
            
            logger.info(
                "Sending email",
                to=to,
                subject=subject,
                has_metadata=bool(metadata)
            )
            
            response = resend.Emails.send(params)
            
            logger.info(
                "Email sent successfully",
                email_id=response.get('id'),
                to=to
            )
            
            return {
                "email_id": response.get('id'),
                "status": "sent",
                "sent_at": datetime.utcnow().isoformat()
            }
        
        except Exception as e:
            logger.error(
                "Failed to send email",
                error=str(e),
                to=to,
                subject=subject
            )
            raise
    
    async def send_booking_inquiry(
        self,
        venue_email: str,
        venue_name: str,
        venue_contact_name: Optional[str],
        message_content: str,
        conversation_id: str,
        booking_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Send a booking inquiry email to a venue
        
        Args:
            venue_email: Venue contact email
            venue_name: Venue name
            venue_contact_name: Contact person's name (optional)
            message_content: Email message content (generated by LLM)
            conversation_id: Database conversation ID for tracking
            booking_id: Related booking ID (optional)
        
        Returns:
            Email send result with email_id
        """
        greeting = f"Hi {venue_contact_name}," if venue_contact_name else "Hello,"
        
        html = f"""
        <html>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
            <p>{greeting}</p>
            {message_content.replace(chr(10), '<br>')}
            <br><br>
            <p>Best regards,</p>
            <p><strong>Sick Day with Ferris Booking Agent</strong><br>
            {self.from_address}<br>
            <a href="https://sickdaywithferris.band">sickdaywithferris.band</a></p>
        </body>
        </html>
        """
        
        text = f"{greeting}\n\n{message_content}\n\nBest regards,\nSick Day with Ferris Booking Agent\n{self.from_address}"
        
        metadata = {
            "conversation_id": conversation_id,
            "message_type": "booking_inquiry",
            "venue_name": venue_name
        }
        
        if booking_id:
            metadata["booking_id"] = booking_id
        
        return await self.send_email(
            to=[venue_email],
            subject=f"Booking Inquiry - Sick Day with Ferris",
            html=html,
            text=text,
            metadata=metadata
        )
    
    async def send_availability_request(
        self,
        band_member_email: str,
        band_member_name: str,
        message_content: str,
        conversation_id: str,
        booking_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Send availability request email to a band member
        
        Args:
            band_member_email: Band member email
            band_member_name: Band member name
            message_content: Email message content (generated by LLM)
            conversation_id: Database conversation ID for tracking
            booking_id: Related booking ID (optional)
        
        Returns:
            Email send result with email_id
        """
        html = f"""
        <html>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
            <p>Hi {band_member_name},</p>
            {message_content.replace(chr(10), '<br>')}
            <br><br>
            <p>Thanks,</p>
            <p><strong>Booking Agent</strong><br>
            {self.from_address}</p>
        </body>
        </html>
        """
        
        text = f"Hi {band_member_name},\n\n{message_content}\n\nThanks,\nBooking Agent\n{self.from_address}"
        
        metadata = {
            "conversation_id": conversation_id,
            "message_type": "availability_request",
            "band_member_name": band_member_name
        }
        
        if booking_id:
            metadata["booking_id"] = booking_id
        
        return await self.send_email(
            to=[band_member_email],
            subject=f"Availability Check - Booking Inquiry",
            html=html,
            text=text,
            metadata=metadata
        )
    
    async def send_contract(
        self,
        venue_email: str,
        venue_name: str,
        venue_contact_name: Optional[str],
        contract_html: str,
        contract_pdf_url: Optional[str],
        conversation_id: str,
        booking_id: str,
        contract_id: str
    ) -> Dict[str, Any]:
        """
        Send finalized contract to venue (only after human approval)
        
        Args:
            venue_email: Venue contact email
            venue_name: Venue name
            venue_contact_name: Contact person's name
            contract_html: HTML version of contract
            contract_pdf_url: URL to PDF contract (if available)
            conversation_id: Database conversation ID
            booking_id: Booking ID
            contract_id: Contract ID
        
        Returns:
            Email send result with email_id
        """
        greeting = f"Hi {venue_contact_name}," if venue_contact_name else "Hello,"
        
        pdf_link = f'<p><a href="{contract_pdf_url}" style="display: inline-block; padding: 10px 20px; background-color: #007bff; color: white; text-decoration: none; border-radius: 5px;">Download PDF Contract</a></p>' if contract_pdf_url else ""
        
        html = f"""
        <html>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
            <p>{greeting}</p>
            <p>Thank you for booking Sick Day with Ferris! Please find the performance contract below.</p>
            {pdf_link}
            <hr style="margin: 20px 0; border: none; border-top: 1px solid #ddd;">
            {contract_html}
            <hr style="margin: 20px 0; border: none; border-top: 1px solid #ddd;">
            <p>Please review, sign, and return the contract at your earliest convenience.</p>
            <br>
            <p>Best regards,</p>
            <p><strong>Sick Day with Ferris</strong><br>
            {self.from_address}</p>
        </body>
        </html>
        """
        
        metadata = {
            "conversation_id": conversation_id,
            "booking_id": booking_id,
            "contract_id": contract_id,
            "message_type": "contract",
            "venue_name": venue_name
        }
        
        return await self.send_email(
            to=[venue_email],
            subject=f"Performance Contract - Sick Day with Ferris at {venue_name}",
            html=html,
            metadata=metadata
        )
    
    def process_inbound_webhook(self, webhook_payload: Dict[str, Any]) -> Dict[str, Any]:
        """
        Process inbound email webhook from Resend
        
        Resend webhook payload for received emails includes:
        - type: Event type (e.g., "email.received")
        - data: Email data including from, to, subject, html, text, etc.
        
        Args:
            webhook_payload: Raw webhook payload from Resend
        
        Returns:
            Parsed email data ready for agent processing
        """
        try:
            event_type = webhook_payload.get('type')
            
            if event_type == 'email.received':
                data = webhook_payload.get('data', {})
                
                # Parse sender
                from_address = data.get('from')
                sender_name, sender_email = parseaddr(from_address) if from_address else (None, None)
                
                # Extract content
                html_content = data.get('html')
                text_content = data.get('text')
                subject = data.get('subject')
                
                # Get recipient (our agent email)
                to_addresses = data.get('to', [])
                
                # Extract metadata/tags if present
                tags = data.get('tags', [])
                metadata = {tag.get('name'): tag.get('value') for tag in tags if isinstance(tag, dict)}
                
                parsed = {
                    "event_type": "email_received",
                    "sender_email": sender_email,
                    "sender_name": sender_name or "Unknown",
                    "to": to_addresses,
                    "subject": subject,
                    "html_content": html_content,
                    "text_content": text_content,
                    "metadata": metadata,
                    "received_at": datetime.utcnow().isoformat(),
                    "raw_payload": webhook_payload
                }
                
                logger.info(
                    "Processed inbound email webhook",
                    sender=sender_email,
                    subject=subject,
                    has_metadata=bool(metadata)
                )
                
                return parsed
            
            elif event_type in ['email.sent', 'email.delivered', 'email.bounced', 'email.complained']:
                # Handle email status events
                data = webhook_payload.get('data', {})
                email_id = data.get('email_id')
                
                logger.info(
                    "Processed email status webhook",
                    event_type=event_type,
                    email_id=email_id
                )
                
                return {
                    "event_type": event_type,
                    "email_id": email_id,
                    "data": data,
                    "received_at": datetime.utcnow().isoformat()
                }
            
            else:
                logger.warning("Unknown webhook event type", event_type=event_type)
                return {
                    "event_type": "unknown",
                    "raw_payload": webhook_payload
                }
        
        except Exception as e:
            logger.error(
                "Failed to process webhook",
                error=str(e),
                payload=webhook_payload
            )
            raise


# Global email service instance
email_service = EmailService()
